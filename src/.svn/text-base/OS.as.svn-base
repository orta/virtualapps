package {  import flash.display.*;  import flash.events.*;  import flash.net.URLRequest;  import flash.display.Loader;  import flash.display.Stage;  import flash.geom.*;  import flash.events.KeyboardEvent;  import gs.*;  import dock.*;  import window.*;  import visor.lt.uza.utils.*;  import visor.Visor;    public class OS extends MovieClip {    private var version:String = "VA version 0.96 - ./orta && dave";    private var lessons:Array = [       "If handcoding buttons, you can skip repeated values for x, y, width, height",      "Click the !!!'s above to change the level of debug",      "Drag this around by the titlebar",       "If you don't include an image file in the XML, it will use one of the same name",      "Submenus are for buttons etc, contextmenus are for rightclicks",      "it's possible to use closewindow to close another window",      "Wallpapers are purty",      "any number of windows are bookmarkable at once",      "OSX menu's don't need to be set to nodrag",      "If using jpgs you can't use the ability to skip the image XML tag",      "Never gonna give you up\nNever gonna let you down\nNever gonna run around and desert you\nNever gonna make you cry\nNever gonna say goodbye\nNever gonna tell a lie and hurt you\n",      "The dock is in a weird position when debug is on, thats fine as its ok in release"];    public var mWindows:Array=new Array();    public var currentApp:String;    public var listOfApps: Array = new Array();    public var listOfUserWindows: Array = new Array();    public var mTLWindows:Array = new Array();    public var mTRWindows:Array = new Array();    public var mBLWindows:Array = new Array();    public var mBRWindows:Array = new Array();    public var undoPoints:Array = new Array();    public var undoStrings:Array = new Array();    public var topBar:DisplayObject = null;    public var bottomBar:DisplayObject = null;     public var menuBar:orWindow = null;    public var hasMenubar:Boolean   = false;    public var allShadows:Boolean   = false;    public var devMode:Boolean      = false;    public var showBorders:Boolean  = true;    public var submenuLock:Boolean  = false;     public var singleWindow:Boolean = true;    public var hasTaskbar:Boolean   = false;    public var hasDock: Boolean	 = false;    public var isVista: Boolean	 = false;     public var applyBlur:Boolean 	 = false;    public var rightAlignedCloseRect:Number = 0;    public var yOffset: int		 = 0;    public var xOffset: int		 = 0;    public var dragDepth: int		 = 79;    public var changeWindowed:Boolean = false;    public var mWallpaper:Loader;    public  var mSubMenu:orWindow = null;    private var mOSSettings: OSSettings;    public var closeRect:Rectangle;    public var submenus:Array = new Array(5);    public var currentSWFAddress:String = "";    public var userLoadedWindows: Array = new Array();    //for SWFs    public var titlecenter: String;    public var titleright : String;    public var titleleft  : String;    public var dockBar:Dock;    //for Visor    private var $:Global = Global.init();    public function OS() {      //load the desktop			            $.stage = stage;      $.console = new Visor(this);      $.console.enable();                  init();            mOSSettings = new OSSettings(this);      handleParams();            dockBar = new Dock(this);      addChild(dockBar);      stage.addEventListener(Event.RESIZE, resizeHandler);      stage.addEventListener(MouseEvent.MOUSE_DOWN, onStageMouseDown);      stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);      stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp);      //this line breaks safari.      $.trace("before");      SWFAddress.addEventListener(SWFAddressEvent.CHANGE, swfAddressChanged);      $.trace("after");    }      public function swfAddressChanged(e: SWFAddressEvent) : void{        var address:String = SWFAddress.getValue();        $.trace3("***SWF Address: " + address + " ***");        if(address.length > 4){          var myInputs:Array = address.split("/");          // look in           $.trace3(myInputs + " = myinput");          $.trace3(userLoadedWindows + " = user winders");          for each(var appStr:String in userLoadedWindows){             // kill anything in ULW but not address            var foundApp:Boolean = false;            for each(var inStr:String in myInputs ){              if(appStr == inStr){                foundApp = true;                $.trace3("Found " +  appStr + " in Address");              }            }            if(foundApp == false){              currentSWFAddress = currentSWFAddress.split(appStr + "/").join("");              var killWin:orWindow = stringToWin(appStr);              $.trace3("Not Found " + killWin.mPath + " in addess - killing");              closeWindow("this", killWin, false);            }          }          for each( inStr in myInputs ){             // open anything in addres and not ULW            foundApp = false;	            if(inStr != ""){              for each( appStr in userLoadedWindows){                 // first delete ones that don't exist                $.trace3(inStr + " (in) = (win) " + appStr + "?");                if(inStr == appStr){                  foundApp = true;                  $.trace3("Found " +  appStr + " in address");                  //address = address.split( appStr + "/").join("");                }              }              if(foundApp == false){                currentSWFAddress += inStr + "/";                $.trace3("Not Found " + inStr + " in ULW - adding, new address will be " + currentSWFAddress);                userLoadedWindows.push( inStr);                addWindow(inStr, false);              }            }            if(inStr == "debug"){				//this may still prove to be useful				// for now its just legacy              if(!devMode){             //   setDevMode();              }else{                $.trace("Dev mode already on");              }            }          }        }        else{          $.trace3("Killing all in ULW cause of / address (" + userLoadedWindows.length +")");          for(var i:int = 0; i < userLoadedWindows.length; i++){            // first delete ones that don't exist            killWin = stringToWin(userLoadedWindows[i]);		            if(killWin != null){              $.trace3("Killing " + killWin.mPath);              currentSWFAddress = currentSWFAddress.split(killWin.mPath + "/").join("");              userLoadedWindows.splice(userLoadedWindows.indexOf(killWin.mPath), 1);              closeWindow("this", killWin, false);						            }else{              $.trace3("Window not found!");            }          }        }        $.trace3( "currentURL = " +currentSWFAddress );      }                  private function init(): void      {        stage.scaleMode = "noScale";        stage.align = "TL";        try{          var wallpaperBG:URLRequest = new URLRequest("img/wallpaper.jpg");          var loader:Loader = new Loader();		          loader.load(wallpaperBG);		          addChild(loader);           mWallpaper = loader;          loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onWallpaperLoaded);        }        catch (error:Error) {          $.trace("No wallpaper found at img/wallpaper.jpg");        }      }      public function onWallpaperLoaded(event:Event):void{        moveWallpaper();      }      public function addSWF(input:String) : SWFWindow{        var newSWF:SWFWindow = new SWFWindow(this, input);        //	mWindows.push(newSWF);        return newSWF;      }      public function addWindow(input:String, userInput:Boolean = true, hasShadow:Boolean = true, wasChangeWindowed:Boolean = false) : orWindow      {			        $.trace3("Adding window (" + input + ")");        if(singleWindow == true){          for each (var winder:orWindow in mWindows) {            if(winder.mPath == input){              $.trace2("Duplicate window detected - removed");              setFrontWindow(winder);              return null;            }          }        }        if(dockBar){          dockBar.update();        }        var desktopWindow:orWindow = new orWindow( this, input, userInput, hasShadow, wasChangeWindowed);        return desktopWindow;      }      public function addWindowFinished(desktopWindow: orWindow) : orWindow      {		        var isFound:Boolean = false;        for each (var theString:String in listOfApps) {          if ( desktopWindow.appName == theString){            isFound = true;          }        }        if(isFound == false){          listOfApps.push(desktopWindow.appName);          if(desktopWindow.appName != ""){            desktopWindow.centered = true;          }          $.trace3("added " + desktopWindow.appName + " to the list of apps");        }        if( (desktopWindow.windowType != Window.WINDOW) && (desktopWindow.windowType != Window.PANEL) ) // for undo managing        {          var i :int = 0;          isFound = false;          for(i; i < undoStrings.length; i++){            if(desktopWindow.mPath == undoStrings[i]){              desktopWindow.x = undoPoints[i].x;              desktopWindow.y = undoPoints[i].y;              isFound = true;            }          }          if(isFound == false){            //for tweaking posistions first time            if(desktopWindow.changeWindowed == false){              desktopWindow.x += desktopWindow.xOffset;              desktopWindow.y += desktopWindow.yOffset;            }            undoPoints.push(new Point(desktopWindow.x, desktopWindow.y));          }        }        else{           // but don't ignore setting offsets for submenus          desktopWindow.x += desktopWindow.xOffset;          desktopWindow.y += desktopWindow.yOffset;        }        mWindows.push(desktopWindow);        if(numChildren-1 < 0)        {          addChild(desktopWindow);        }        else {          addChildAt(desktopWindow, numChildren);        }        if(desktopWindow.userMade == true && desktopWindow.windowType == Window.WINDOW){          currentSWFAddress += desktopWindow.mPath + "/"; // add the current xml filepath to the address string          userLoadedWindows.push(desktopWindow.mPath);          $.trace3("setting current SWFAddress to " + currentSWFAddress);          SWFAddress.setValue( currentSWFAddress );        }        return desktopWindow;      }      public function killAllSubMenus() :void      {        for (var i:int = 0; i < mWindows.length; i++) {          if( mWindows[i].windowType == Window.SUB_MENU){            closeWindow("this", mWindows[i] );          }        }					      }      public function addPanel(input:String, myParent:orWindow) : orWindow      {        var panel:orWindow = new orWindow( this, input, false);			        panel.draggable = false;        myParent.draggable = false;        panel.windowType = Window.PANEL;        mWindows.push(panel);        if(numChildren-1 < 0)        {          addChild(panel);        }        else {          addChildAt(panel, numChildren);        }        panel.mParent = myParent;        return panel;      }      public function addSubMenu(input:String, startPoint:Point, subParent:orWindow) : orWindow      {        if((mSubMenu != null) && (mSubMenu != subParent) && (mSubMenu != subParent.mParent)) {          $.trace2("submenu already exists, killing");          killAllSubMenus();          mSubMenu = null;        }        var subMenu:orWindow = new orWindow( this, input, false);			        subMenu.draggable = false          subMenu.windowType = Window.SUB_MENU;        subMenu.screwOS = subParent.screwOS;        subMenu.x = startPoint.x;        subMenu.y = startPoint.y;        mWindows.push(subMenu);        if(numChildren-1 < 0)        {          addChild(subMenu);        }        else {          addChildAt(subMenu, numChildren);        }        if (mSubMenu != subParent){          mSubMenu = subMenu;        }        subMenu.mParent = subParent;        subMenu.mParent.mChild = subMenu;        submenuLock = false;        return subMenu;      }      public function setCurrentApplication(appName : String) :void{        if(this.currentApp == appName) {$.trace3("same application"); return; }         if(appName == "null")		   {$.trace3("no application"); return;}        $.trace2("Application set to " + appName);			        this.currentApp = appName;        if(this.topBar != null){          if(menuBar != null){            loadMenuBar();          }else{            menuBar = addWindow(currentApp + "menu", false, false)              menuBar.screwOS = true;			            menuBar.windowType = Window.MENU_BAR;            menuBar.filters = [];          }        }      }      private function loadMenuBar() :void{        $.trace3("changing menubar");        closeWindow("this", menuBar, false);			        menuBar = addWindow(currentApp + "menu", false);        menuBar.screwOS = true;							        menuBar.windowType = Window.MENU_BAR;        menuBar.filters = null;      }      public function setFrontWindow(inputWindow:Window) :void{        if(mSubMenu != null){          $.trace2("submenu already exists, killing");          closeWindow("this", mSubMenu);          killAllSubMenus();        }			                // are we in the children list?        var okay:Boolean = false;        if(inputWindow == null){ return;}        for(var i:int; i < numChildren ; i++){ 				          if(inputWindow == getChildAt(i) ){            okay = true;          }        }        if(okay){          setChildIndex(inputWindow, numChildren-1);          setCurrentApplication(inputWindow.appName);        }        if( (isVista == true) && (applyBlur == true) || inputWindow.windowType == Window.SUB_MENU){          // so we make the display actually composite here          // by rendering the foremost, then hiding then the one before          // then hiding etc          for(i = numChildren -1; i > -1; i--){ 		            var inWin:DisplayObject = getChildAt(i);            try{              inputWindow =  Window(inWin) ;            }catch(err:Error) {              //some things in the heirarchy aren't               // actually orWindows, think BlurBG/Highlighters              // so we skip them                            //TODO : This is likely wrong            }            finally{              inputWindow.mBlurBG.updateBlur();              inputWindow.visible = false;            }          }          for(i = numChildren -1; i > -1 ; i--){             inWin = getChildAt(i);            try{              inputWindow =  Window(inWin) ;            }            catch(err:Error) {            }            finally{                     inputWindow.visible = true;            }          }        }      }      public function changeWindow(input:String, inputWindow:orWindow) :void{        var myWindow:orWindow = addWindow(input, false, true, true);         //things that count        if(myWindow == null) return;        myWindow.x = inputWindow.x;        myWindow.y = inputWindow.y;        myWindow.mParent = inputWindow.mParent;        myWindow.mChild = inputWindow.mChild;        myWindow.draggable = inputWindow.draggable;			        //remove the old one from userwinders        currentSWFAddress = currentSWFAddress.split(inputWindow.mPath + "/").join("");        userLoadedWindows.splice(userLoadedWindows.indexOf(inputWindow.mPath), 1);        closeWindow("this", inputWindow, true);        currentSWFAddress = currentSWFAddress + myWindow.mPath + "/";		        userLoadedWindows.push(myWindow.mPath);        // just an update        SWFAddress.setValue( currentSWFAddress );      }      public function closeWindow(input:String, inputWindow:orWindow, ignoreSWFAddress:Boolean = false) :void  {        if(input == "this")        {	          $.trace3("Closing "+ inputWindow.mPath + " it is made by user =" + inputWindow.userMade +"");          if(inputWindow.windowType == Window.PANEL){            $.trace2("Letting parent move again");             inputWindow.mParent.displayingPanel = false;            inputWindow.mParent.draggable = true;          }          var winName:String = "";          if(inputWindow.mChild){            $.trace2(" Killing Child Window");            closeWindow("this", inputWindow.mChild);          }          else{             $.trace3(" and it has no children");	          }          if(inputWindow.windowType == Window.WINDOW){            for(var i:int = 0; i < userLoadedWindows.length; i++){              if(userLoadedWindows[i] == inputWindow.mPath){                userLoadedWindows.splice(i,1); // bye bye              }            }            if(ignoreSWFAddress == false){              for(i = 0; i < listOfApps.length; i++){                if(listOfApps[i] == inputWindow.appName){                  trace("removing " +listOfApps[i] + " from list of apps because of " + inputWindow.mPath)                    listOfApps.splice(i,1);                  if(dockBar != null){                    dockBar.update();                  }                }              }            }          }          try{            if(ignoreSWFAddress == false && inputWindow.userMade == true){              currentSWFAddress = currentSWFAddress.split(inputWindow.mPath + "/").join("");              SWFAddress.setValue( currentSWFAddress );            }            winName = inputWindow.mPath;            removeChild(inputWindow);            mWindows.splice(mWindows.indexOf(inputWindow), 1);          }catch(err:Error){            trace("bad closure of window " + winName + "? " + err.toString());          }        }        else if(input == "parent"){          closeWindow("this", inputWindow.mParent, ignoreSWFAddress);        }        else{	          for (i = 0; i > mWindows.length; i++){            // loop for the window and kill it                        if( mWindows[i].mPath == input){              //my AI lecturer would love to see this              closeWindow("this", mWindows[i]);            }          }        }      }      private function stringToWin(inputString:String):orWindow{        var i:int;        for (i = 0; i < mWindows.length; i++) {          if( mWindows[i].mPath == inputString){            return mWindows[i];          }        }				        return null;      }      private function handleParams(): void {        try {          var keyStr:String;          var valueStr:String;          var paramObj:Object = LoaderInfo(this.root.loaderInfo).parameters;          $.trace("Found parameters:" + root.loaderInfo.parameters.length);          for (keyStr in paramObj) {            valueStr = String(paramObj[keyStr]);            $.trace("   \t" + keyStr + ":\t" + valueStr);            var pattern:RegExp = /openwin*/;   //anything that begins with openwin will open the result param            if(pattern.test(keyStr) == true){              addWindow(valueStr, false);            }          }        }        catch (error:Error) {          $.trace("Params Error:" + error);        }      }		      private function onKeyUp(event:KeyboardEvent):void      {				        $.trace3("KeyUp Keycode: " + event.keyCode);        if(event.keyCode == 32){		          if(devMode == true){            for each (var winder:orWindow in mWindows) {              if(winder.screwOS == false){                for each (var button:Highlighter in winder.myHighlighters) {                  button.addText();                }              }            }	          }else{             for each (var winder2:orWindow in mWindows) {              for each (var button2:Highlighter in winder2.myHighlighters) {                button2.mAlpha = 0.0;                button2.drawme();              }            }	          }        }      }            public function toggleFullscreen():void{        switch(stage.displayState) {          case "normal":            stage.displayState = "fullScreen";              break;          case "fullScreen":          default:            stage.displayState = "normal";              break;        }      }      private function onStageMouseDown(event:MouseEvent):void{        killAllSubMenus();      }      private function onKeyDown(event:KeyboardEvent):void      {	       // $.trace3("KeyDown Keycode: " + event.keyCode);        if(event.keyCode == 192){           // ` - visor          $.console.toggleVisor();          event.stopPropagation();        }        if(event.keyCode == 90){          trace("uh?");        }        //for hiding debug text        if(event.keyCode == 32){		          if(devMode == true){            for each (var winder:orWindow in mWindows) {              if(winder.screwOS == false){                for each (var button:Highlighter in winder.myHighlighters) {                  button.removeText();                }              }            }	          }else{            for each (var winder2:orWindow in mWindows) {              for each (var button2:Highlighter in winder2.myHighlighters) {                button2.mAlpha = 0.5;                button2.drawme();              }            }	          }        }      }      public function getFrontMostWindow() :DisplayObject{        //this isn't correct, its too simple        var returnWindow:DisplayObject = getChildAt(0);        if(returnWindow){          return returnWindow;        }        return null;      }      private function resizeHandler(event:Event):void{        //when the entire stage is resized        moveWallpaper();        keepStickyWindows();        $.trace3("Stage resize to:(" + stage.width + ", " + stage.height + ")" );      }      private function moveWallpaper():void{        mWallpaper.x = stage.stageWidth - mWallpaper.width;        mWallpaper.y = stage.stageHeight - mWallpaper.height;      }      public function keepStickyWindows():void{        //err, I could make an awesome joke here. But I won't.         //...This is just for keeping the static windows in the right place        if(topBar != null){          topBar.width = stage.stageWidth;        }        if(bottomBar != null){          bottomBar.y = stage.stageHeight- bottomBar.height;          bottomBar.width = stage.stageWidth;        }        if(dockBar != null){          dockBar.x = (stage.stageWidth / 2) - (dockBar.width / 2);          dockBar.y = (stage.stageHeight - 64)          }          var shoveAcross:Number = 0;          var winder:orWindow;          for each ( winder in mTLWindows) {            //top left            winder.y = 0;            winder.x = shoveAcross;            shoveAcross += winder.width;          }          shoveAcross = 0;          for each (winder in mTRWindows) {             // top right	            shoveAcross += winder.width;            winder.x = stage.stageWidth - shoveAcross;		            winder.y = 0;          }          shoveAcross = 0;          for each (winder in mBLWindows) {            // bottom left            winder.y = stage.stageHeight - winder.height;            winder.x = shoveAcross;            shoveAcross += winder.width;          }          shoveAcross = 0;          for each (winder in mBRWindows) {             // bottom right            shoveAcross += winder.width;            winder.y = stage.stageHeight - winder.height;            winder.x = stage.stageWidth - shoveAcross;          }        }      }    }