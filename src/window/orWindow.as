package window {	  import flash.display.*;  import flash.xml.XMLDocument;  import flash.geom.Rectangle;  import flash.geom.Point;  import flash.ui.Keyboard;  import flash.events.*;  import flash.net.URLLoader;  import flash.net.URLRequest;  import flash.events.ErrorEvent;  import flash.events.MouseEvent;  import flash.display.Loader;  import flash.filters.DropShadowFilter;  import flash.text.TextField;  import gs.*;  import visor.lt.uza.utils.*;    /* *     *	main window class for displaying images     *       *     *	@langversion ActionScript 3.0     *	@playerversion Flash 9.0     *     *	@author orta     *	@since  2008-04-14     * */  public class orWindow extends Window {    public var draggable:Boolean = true;    public var myHighlighters:Array = new Array();    public var mParent:orWindow;    public var mChild:orWindow;    public var centered:Boolean;    public var displayingPanel:Boolean = false;    public var xOffset:Number = 0;    public var yOffset:Number = 0;    public var userMade:Boolean = true;    public var screwOS:Boolean = true; // does it go in the OS's windows list    public var hasShadow:Boolean = true;    public var addDefault:Boolean = true;    public var changeWindowed:Boolean = false;        private var loader:Loader;    private var imagePath:String;    private var dragDepth:Number = 72;    private var buttonActions:Array = new Array();    private var buttonRects:Array = new Array();    private var buttonTargets:Array = new Array();    private var $:Global = Global.init();    public function orWindow(myOS:OS, myPath:String, userAction:Boolean = true, allowShadows:Boolean = true, wasChangeWindowed:Boolean = false)  {      $.trace3("orWindow created");			      mOS = myOS;      mPath = myPath;       dragDepth = mOS.dragDepth;      changeWindowed = wasChangeWindowed;      userMade = userAction;      hasShadow = allowShadows;      imagePath = myPath;      try{			        var xmlString:URLRequest = new URLRequest("xml/" + myPath + ".xml");        var xmlLoader:URLLoader = new URLLoader(xmlString);      }      catch(error:IOErrorEvent){        $.trace("XML not found at path: " + imagePath + " error =" +error.text);      }									      xmlLoader.addEventListener(Event.COMPLETE, xmlLoaded);      xmlLoader.addEventListener(IOErrorEvent.IO_ERROR, onIOError);    }    private function onIOError(event:Event): void {      $.trace("Error loading " + this.mPath + " \n Error = " + event.toString());    }    private function xmlLoaded(event:Event): void {      $.trace3("xml loaded");      try{        var xDoc:XMLDocument=new XMLDocument;        xDoc.ignoreWhite=true;        var mXML:XML=XML(event.target.data);        xDoc.parseXML(mXML.toXMLString());      }catch(err:Error){        $.trace("XML Loading error on " + this.mPath + ": " + err.toString() + " most likely an unclosed tag");        return;      }      appName = mXML.appname;      if(appName == ""){        $.trace3("no appname for window, setting to nothing");        appName = "null";      }            if(mXML.grabdepth.toString() != ""){        dragDepth = mXML.grabDepth;      }      if(mXML.stick == "TR"){        mOS.mTRWindows.push(this);		      }      else if(mXML.stick == "TL"){        mOS.mTLWindows.push(this);      }      else if(mXML.stick == "BR"){	        mOS.mBRWindows.push(this);      }      else if(mXML.stick == "BL"){				        mOS.mBLWindows.push(this);      }else{        screwOS = false;      }      if( (mXML.needsshadow == "yes") || (mOS.allShadows == true) && (screwOS == false) && (hasShadow == true) && (windowType != MENU_BAR)) {        /* good enough check for OSX */        var dropShadow:DropShadowFilter = new DropShadowFilter();        dropShadow.color = 0x000000;                if(mOS.hasDock){                            dropShadow.strength = 1;              dropShadow.blurX = 60;              dropShadow.blurY = 60;              dropShadow.angle = 90;              dropShadow.alpha = 0.6;              dropShadow.distance = 22;              filters = [dropShadow];        }                 else{          dropShadow.strength = 0.4;          dropShadow.blurX = 30;          dropShadow.blurY = 30;          dropShadow.angle = 90;          dropShadow.alpha = 0.5;          dropShadow.distance = 8;          filters = [dropShadow];         }              }      if(mXML.xoffset.toString() != "") {        xOffset = mXML.xoffset;      }      if(mXML.yoffset.toString() != "") {        yOffset = mXML.yoffset;      }      if(mXML.nodrag == "yes") {        draggable = false;      }      if(mXML.defaultclose == "no") {        addDefault = false;      }      if(mXML.centered == "yes") {        centered = true;      }      if(mXML.image.toString() == "") {				        imagePath =  "img/" + imagePath + ".png";      }      else {          //no need to have a image path if it's the same name		        imagePath =  "img/" + mXML.image;      }      try{        loader = new Loader();         var imageURL:URLRequest = new URLRequest(imagePath);        loader.load(imageURL);      }      catch(error:IOErrorEvent) {        $.trace("Image not found at path: " + imagePath + " error =" +error);      }      loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onLoadingComplete);      this.addChild(loader);      var tempX:Number, tempY:Number, tempW:Number, tempH:Number;      if(draggable == true){         if(mOS.closeRect && addDefault) {          buttonRects.push(mOS.closeRect);          buttonActions.push("closewindow");          buttonTargets.push("this");          var mHitbox:Highlighter = new Highlighter( mOS.closeRect.width,  mOS.closeRect.height, "x");          mHitbox.x =  mOS.closeRect.x;          mHitbox.y =  mOS.closeRect.y;         // mHitbox.mBorder = 0.2;          myHighlighters.push(mHitbox);		          addChild(mHitbox);        }      }                  var buttonList:XMLList = mXML.button;      for each (var button:XML in buttonList) {        if(button.x.toString() == "") { button.x = tempX;  }        if(button.y.toString() == "") { button.y = tempY; }        if(button.width.toString() == "") { button.width = tempW; }        if(button.height.toString() == "") { button.height = tempH; }        var myRect:Rectangle = new Rectangle(button.x, button.y, button.width, button.height);        buttonRects.push(myRect);        // add the type of click it is        buttonActions.push(button.clickaction.attribute("type"));        buttonTargets.push(button.clickaction);        tempX = button.x;        tempY = button.y;        tempW = button.width;        tempH = button.height;        var myHitbox:Highlighter = new Highlighter( button.width, button.height, button.clickaction + " - " + button.clickaction.attribute("type"));        myHitbox.x = button.x;        myHitbox.y = button.y;        myHighlighters.push(myHitbox);        if(mOS.devMode == true && screwOS == false){          myHitbox.addText();        }        addChild(myHitbox);      }      if(mOS.devMode == true && screwOS == false){        drawTag();      }      addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);      addEventListener(MouseEvent.MOUSE_UP, onMouseUp);          }    private function onLoadingComplete(event:Event):void{      // when images is DLed      mOS.addWindowFinished(this);      if(mOS.closeRect && mOS.rightAlignedCloseRect && !screwOS ){         // windows has to have X buttons on the hard side :/        buttonRects[0].x = this.width - buttonRects[0].width - mOS.rightAlignedCloseRect;        myHighlighters[0].x = this.width - myHighlighters[0].width - mOS.rightAlignedCloseRect;      }      if(windowType == SUB_MENU || mOS.isVista){        if (mOS.applyBlur) {          $.trace3("turning on blur");             var ract:Rectangle = new Rectangle(this.x, this.y, loader.width, loader.height);          mBlurBG = new BlurBG(this, ract, mOS);          addChild(mBlurBG);        }      }      if(windowType == PANEL){         // am I an attatched panel?        if(mParent.mParent != null){           // is a submenu loading this?          x = ( (mParent.mParent.x + (mParent.mParent.width / 2 ) ) - (width/2) );          y = mParent.mParent.y + 48;        }else{          x = ( (mParent.x + (mParent.width / 2 ) ) - (width/2) );          y = mParent.y + 48;        }      }      //positionings      if(centered){        if( (windowType != MENU_BAR) && (windowType != SUB_MENU) ){          this.y  = (stage.stageHeight /2) - (loader.height/2);          this.x  = (stage.stageWidth  /2)  - (loader.width /2);          $.trace3("centering window to (" + y + ", " + x + ")");        }      }      else{        // anything that can move will not have had it's positions set yet.        if(draggable == true){           if(mOS.topBar != null){            if(y < mOS.topBar.height){              y = mOS.topBar.height + 1;            }          }          var px:Number, py:Number;          if( (x + width) > stage.stageWidth){            x = stage.stageWidth - width - 10;          }          if( (y + height) > stage.stageHeight){            y = stage.stageHeight - height - 10;          }			        }      }      if((draggable == true ) && (changeWindowed == false)){        for each (var winder:orWindow in mOS.mWindows) {          if(winder.x == x && winder.y == y){            this.x += 32; this.y += 32;          }        }        mOS.setCurrentApplication(appName);      }      mOS.keepStickyWindows();    }    private function onMouseDown(event:MouseEvent):void {	      if(displayingPanel){        return;      }      if(draggable == true && screwOS == false){        if(event.localY < dragDepth ) {          // finder is 56          // windows is probably 32          //TODO : Make constraints right?          if(mOS.topBar != null){            var constraints:Rectangle = new Rectangle( -600, -20 , stage.stageWidth+ 600, stage.stageHeight - 90);            constraints.y += mOS.topBar.height;            this.startDrag(false, constraints);          }          else{            this.startDrag();          }          if(mOS.isVista){            mBlurBG.startTimer();          }        }      }      //set the TR of the window to 0,0      var mousePoint:Point = new Point(event.stageX, event.stageY);      mousePoint.x -= this.x;      mousePoint.y -= this.y;      for (var i:int = 0; buttonRects.length > i ; i++) {        if(buttonRects[i] != null){          if(buttonRects[i].containsPoint( mousePoint ) ){            $.trace3("clicked on " + i);            $.trace3(buttonActions[i] + " " + buttonTargets[i]);            if(buttonActions[i] == "closewindow") {              mOS.currentSWFAddress = mOS.currentSWFAddress.split(mPath + "/").join("");              SWFAddress.setValue( mOS.currentSWFAddress );              mOS.closeWindow(buttonTargets[i], this);              $.trace2("closewindow  - " + buttonTargets[i]);              if(windowType == SUB_MENU){                mOS.mSubMenu = null;              }              return;            }            if(buttonActions[i] ==  "changewindow") {              if(buttonTargets[i].mPath != this.mPath){                                // if its a submenu with changewindow make it apply to parent                if(this.windowType == Window.SUB_MENU){                  mOS.changeWindow(buttonTargets[i], this.mParent);                  $.trace2("changewindow to - " + buttonTargets[i]);                                  }else{                    mOS.changeWindow(buttonTargets[i], this);                    $.trace2("changewindow to - " + buttonTargets[i]);                    }                if(windowType == SUB_MENU){                  mOS.mSubMenu = null;                }                return;              }            }            if(buttonActions[i] ==  "openwindow") {							              $.trace2("openwindow  - " + buttonTargets[i]);              mOS.addWindow(buttonTargets[i] );              if(windowType == SUB_MENU){                mOS.mSubMenu = null;              }            }            //The returns on these below are debatable.            if(buttonActions[i] ==  "contextmenu")	{              // right click              $.trace2("contextmenu  - " + buttonTargets[i]);              var currentPoint :Point = new Point();              currentPoint.x = event.stageX;              currentPoint.y = event.stageY;              mOS.addSubMenu(buttonTargets[i], currentPoint, this);              return;            }            if(buttonActions[i] ==  "openpanel") {              $.trace2("opening panel  - " + buttonTargets[i]);              displayingPanel = true;              mOS.addPanel(buttonTargets[i], this);              this.draggable = false;              return;            }            if(buttonActions[i] ==  "submenu")	{								              $.trace2("submenu  - " + buttonTargets[i]);              if(!mOS.submenuLock){                var subPoint :Point = new Point();                subPoint.y = buttonRects[i].y + buttonRects[i].height;                subPoint.y += this.y;                subPoint.x = buttonRects[i].x;                subPoint.x += this.x;                mOS.submenuLock = true;                $.trace3("Submenu created at point (" + subPoint.x + ", " + subPoint.y + ")");                mOS.addSubMenu(buttonTargets[i], subPoint, this);              }else{                $.trace2("Submenu is currently locked");              }              return;            }            if(buttonActions[i] ==  "changeparent") {              if(this.mParent){                mOS.changeWindow(buttonTargets[i], this.mParent);                $.trace2("changeparent  - " + buttonTargets[i] +" " + this.mParent );                mOS.closeWindow("this", this);              }              if(windowType == SUB_MENU){                mOS.mSubMenu = null;              }              return;            }            if(buttonActions[i] ==  "href"){              SWFAddress.href(buttonTargets[i],"_self");              return;            }            if(buttonActions[i] ==  "popup"){              SWFAddress.popup(buttonTargets[i],"","","");              return;            }					            $.trace3("buttonAction = " + buttonActions[i]);          }        }      }			      mOS.setFrontWindow(this);    }    private function onMouseUp(event:MouseEvent):void {      stopDrag();      if(mOS.isVista){        try{          mBlurBG.stopTimer();        }catch(err:Error){          // when dealing with submenus this object may already be dead?!          // then we're fine to let the error pass us by.        }      }      // update undo manager for new location      if( (windowType != WINDOW) && (windowType != PANEL) ){        var i:int = 0;        for(i; i < mOS.undoStrings.length; i++){          if(mPath == mOS.undoStrings[i]){            mOS.undoPoints[i].x = x;            mOS.undoPoints[i].y = y;          }        }      }    }    public function drawTag():void {      var textBit:TextField = new TextField();      textBit.text = mPath + ".xml - " + appName;      textBit.selectable = false;      textBit.y -= 20;      graphics.beginFill( 0x465D74 , 0.6 );            graphics.drawRect( 0,-20 , textBit.width, 20 );            graphics.endFill( );      addChild(textBit);    }    public override function toString() : String {      return "orWindow : '" + mPath + "'";    }  }}